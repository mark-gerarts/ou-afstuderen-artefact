{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TopHat Visualizations Interactive visualizations of TopHat programs. This library exposes the visualizeTask function, which creates a web application for the given task. Examples can be found in the app folder.","title":"Home"},{"location":"#tophat-visualizations","text":"Interactive visualizations of TopHat programs. This library exposes the visualizeTask function, which creates a web application for the given task. Examples can be found in the app folder.","title":"TopHat Visualizations"},{"location":"development/","text":"Development setup One-time commands Run the following once to fetch and build all Haskell dependencies. All commands are intended to be run in the project root. $ stack setup $ stack build Next, fetch all frontend dependencies: $ npm ci --prefix=frontend Compile the CSS: $ npm run css-build-dev --prefix=frontend Nix Most commands have alternatives for Nix -users. For example: $ nix-shell --run css-build-dev Or enter the shell and run your commands from there: $ nix-shell $ css-build-dev To get a complete overview, take a look at the shell.nix file. Development flow Backend To run the backend with hot reload enabled we use yesod-bin : $ stack build yesod-bin # Only needed once $ stack exec -- yesod devel Or alternatively with nix: $ nix-shell --run serve-backend This will spin up a server at localhost:3000 and automatically rebuild the Haskell part of the application whenever a file is changed under the src/ directory. Manual building is still needed when making changes in the app/ folder. Note: yesod devel uses app/devel.hs as its entrypoint, not app/Main.hs . Sometimes yesod devel borks, and does not build upon first starting the dev server. If this happens, simply change and save a project file to force a rebuild. Frontend With the backend server up and running, open up a separate terminal and run the following to get the frontend development environment up: $ spago build $ npm run serve Alternatively: $ nix-shell --run serve-ui This uses Parcel to provide live reloading of the frontend. It will automatically open a browser at localhost:3001 . When the frontend development environment is started this way, it will assume the backend is available at port 3000 - which it should be when using yesod devel . Spinning up both the backend and frontend is combined in a single Nix alias: $ nix-shell --run serve-both VSCode Set up a multi-root workspace for both the root project directory and the frontend directory. This is needed to get the PureScript IDE extension to work correctly. For Nix users, keep in mind to start VSCode from the nix-shell environment: $ nix-shell --run 'code .' Hoogle It's possible to generate a local Hoogle server for the project: $ stack test --fast --haddock-deps $ hoogle generate --local=./ $ hoogle server --local --port=8080 With nix: $ nix-shell --run local-hoogle The local Hoogle server can be found at http://localhost:8080 . Grab yourself a cup of coffee if it's the first time you run this. Also, the command needs to be run again in case of changes in code/dependencies. Building a release Building a release (i.e. a non-dev environment) involves: Building the CSS Compiling the PureScript application Building the Haskell executable $ npm run build-prod --prefix=frontend $ stack build With this in place you can use stack run to start the application at http://localhost:3000 . To use a different port, set the PORT environment variable: $ PORT=80 stack run A note on Prelude TopHat has its own Prelude module which is for a part a reexport of Relude . It is possible to depend on TopHat as a library and still use the plain old Prelude using mixins , but unfortunately this breaks IDE integration . The solution is to rely on Cabal instead of Stack in hie.yaml , but this requires manually installing TopHat, since it is not available on Hackage. Instead we've chosen to simply not use mixins, and to just embrace the Prelude of Tophat/Relude. Since Relude uses Text, we've also added OverloadedStrings as a global flag.","title":"Development"},{"location":"development/#development-setup","text":"","title":"Development setup"},{"location":"development/#one-time-commands","text":"Run the following once to fetch and build all Haskell dependencies. All commands are intended to be run in the project root. $ stack setup $ stack build Next, fetch all frontend dependencies: $ npm ci --prefix=frontend Compile the CSS: $ npm run css-build-dev --prefix=frontend","title":"One-time commands"},{"location":"development/#nix","text":"Most commands have alternatives for Nix -users. For example: $ nix-shell --run css-build-dev Or enter the shell and run your commands from there: $ nix-shell $ css-build-dev To get a complete overview, take a look at the shell.nix file.","title":"Nix"},{"location":"development/#development-flow","text":"","title":"Development flow"},{"location":"development/#backend","text":"To run the backend with hot reload enabled we use yesod-bin : $ stack build yesod-bin # Only needed once $ stack exec -- yesod devel Or alternatively with nix: $ nix-shell --run serve-backend This will spin up a server at localhost:3000 and automatically rebuild the Haskell part of the application whenever a file is changed under the src/ directory. Manual building is still needed when making changes in the app/ folder. Note: yesod devel uses app/devel.hs as its entrypoint, not app/Main.hs . Sometimes yesod devel borks, and does not build upon first starting the dev server. If this happens, simply change and save a project file to force a rebuild.","title":"Backend"},{"location":"development/#frontend","text":"With the backend server up and running, open up a separate terminal and run the following to get the frontend development environment up: $ spago build $ npm run serve Alternatively: $ nix-shell --run serve-ui This uses Parcel to provide live reloading of the frontend. It will automatically open a browser at localhost:3001 . When the frontend development environment is started this way, it will assume the backend is available at port 3000 - which it should be when using yesod devel . Spinning up both the backend and frontend is combined in a single Nix alias: $ nix-shell --run serve-both","title":"Frontend"},{"location":"development/#vscode","text":"Set up a multi-root workspace for both the root project directory and the frontend directory. This is needed to get the PureScript IDE extension to work correctly. For Nix users, keep in mind to start VSCode from the nix-shell environment: $ nix-shell --run 'code .'","title":"VSCode"},{"location":"development/#hoogle","text":"It's possible to generate a local Hoogle server for the project: $ stack test --fast --haddock-deps $ hoogle generate --local=./ $ hoogle server --local --port=8080 With nix: $ nix-shell --run local-hoogle The local Hoogle server can be found at http://localhost:8080 . Grab yourself a cup of coffee if it's the first time you run this. Also, the command needs to be run again in case of changes in code/dependencies.","title":"Hoogle"},{"location":"development/#building-a-release","text":"Building a release (i.e. a non-dev environment) involves: Building the CSS Compiling the PureScript application Building the Haskell executable $ npm run build-prod --prefix=frontend $ stack build With this in place you can use stack run to start the application at http://localhost:3000 . To use a different port, set the PORT environment variable: $ PORT=80 stack run","title":"Building a release"},{"location":"development/#a-note-on-prelude","text":"TopHat has its own Prelude module which is for a part a reexport of Relude . It is possible to depend on TopHat as a library and still use the plain old Prelude using mixins , but unfortunately this breaks IDE integration . The solution is to rely on Cabal instead of Stack in hie.yaml , but this requires manually installing TopHat, since it is not available on Hackage. Instead we've chosen to simply not use mixins, and to just embrace the Prelude of Tophat/Relude. Since Relude uses Text, we've also added OverloadedStrings as a global flag.","title":"A note on Prelude"},{"location":"documentation/","text":"Documentation Documentation is generated from the docs folder using mkdocs . When making documentation changes, you can run the following to get a local preview: mkdocs serve Once everything looks good, the changes can be pushed to the gh-pages branch with the following command: mkdocs gh-deploy","title":"Documentation"},{"location":"documentation/#documentation","text":"Documentation is generated from the docs folder using mkdocs . When making documentation changes, you can run the following to get a local preview: mkdocs serve Once everything looks good, the changes can be pushed to the gh-pages branch with the following command: mkdocs gh-deploy","title":"Documentation"},{"location":"testing/","text":"Testing We've created an end-to-end test suite using Playwright to provide browser interaction, combined with jest as test runner. Installation & usage The test suite is dockerized, so we could (hypothetically for now) include it in CI/CD. In order to run it: Build the container: $ docker build . -f Dockerfile.e2e -t e2e-tests Note: this takes a while to run for the first time, because: We start from the stack-build image, which is large (~4GB) We install playwright, which comes with Chromium included We have to install and compile all Haskell dependencies Run the test suite: $ docker run --rm e2e-tests With nix, both commands are combined in nix-shell --run e2e . The non-docker way Since the dockerized version basically duplicates our local development setup, you could just install the test setup locally, which would be faster: $ npm ci --prefix=e2e $ npm run test --prefix=e2e Developing tests What works easiest for me is: First, start a local server for the page you're testing: $ stack runghc e2e/task/UpdateString.hs This allows you to check what is going on, and play around with the selectors etc that you're using in the tests. Then run the test suite either directly or using docker, as explained above. To create a new test suite: Create a new test suite: e2e/src/your-new-test.e2e.js Create a new task to test: e2e/task/YourNewTest.hs Add a new entry to spin up a server in e2e/jest-playwright.config.js Make sure you use a unique port number Use this port in your test suite The following links are useful when writing tests: Interacting with the browser: Playwright docs All available matchers ( expect(..) ): Jest docs Additional common matchers: expect-playwright","title":"Testing"},{"location":"testing/#testing","text":"We've created an end-to-end test suite using Playwright to provide browser interaction, combined with jest as test runner.","title":"Testing"},{"location":"testing/#installation-usage","text":"The test suite is dockerized, so we could (hypothetically for now) include it in CI/CD. In order to run it: Build the container: $ docker build . -f Dockerfile.e2e -t e2e-tests Note: this takes a while to run for the first time, because: We start from the stack-build image, which is large (~4GB) We install playwright, which comes with Chromium included We have to install and compile all Haskell dependencies Run the test suite: $ docker run --rm e2e-tests With nix, both commands are combined in nix-shell --run e2e .","title":"Installation &amp; usage"},{"location":"testing/#the-non-docker-way","text":"Since the dockerized version basically duplicates our local development setup, you could just install the test setup locally, which would be faster: $ npm ci --prefix=e2e $ npm run test --prefix=e2e","title":"The non-docker way"},{"location":"testing/#developing-tests","text":"What works easiest for me is: First, start a local server for the page you're testing: $ stack runghc e2e/task/UpdateString.hs This allows you to check what is going on, and play around with the selectors etc that you're using in the tests. Then run the test suite either directly or using docker, as explained above. To create a new test suite: Create a new test suite: e2e/src/your-new-test.e2e.js Create a new task to test: e2e/task/YourNewTest.hs Add a new entry to spin up a server in e2e/jest-playwright.config.js Make sure you use a unique port number Use this port in your test suite The following links are useful when writing tests: Interacting with the browser: Playwright docs All available matchers ( expect(..) ): Jest docs Additional common matchers: expect-playwright","title":"Developing tests"},{"location":"usage/","text":"Installation & Usage Installation The project is currently untested as a library, however it should just work. Keep in mind that TopHat uses a custom Prelude, so you will have to use a mixin or some other solution. Usage The library exposes a single function: visualizeTask . The library will spin up a web server to visualize the passed task. By default, the application can be accessed at http://localhost:3000 . The port number can be changed by passing it as an environment variable, e.g.: PORT=3001 stack run Consider the following example: {-# LANGUAGE OverloadedStrings #-} import Task (Task, enter, view, (>>?)) import Visualize (visualizeTask) main :: IO () main = visualizeTask greet greet :: Task h Text greet = (question >< promptName) >>? \\(_, name) -> view (\"Hello, \" <> name) where question :: Task h Text question = view \"What is your name?\" promptName :: Task h Text promptName = enter This will produce the following application when run:","title":"Installation & usage"},{"location":"usage/#installation-usage","text":"","title":"Installation &amp; Usage"},{"location":"usage/#installation","text":"The project is currently untested as a library, however it should just work. Keep in mind that TopHat uses a custom Prelude, so you will have to use a mixin or some other solution.","title":"Installation"},{"location":"usage/#usage","text":"The library exposes a single function: visualizeTask . The library will spin up a web server to visualize the passed task. By default, the application can be accessed at http://localhost:3000 . The port number can be changed by passing it as an environment variable, e.g.: PORT=3001 stack run Consider the following example: {-# LANGUAGE OverloadedStrings #-} import Task (Task, enter, view, (>>?)) import Visualize (visualizeTask) main :: IO () main = visualizeTask greet greet :: Task h Text greet = (question >< promptName) >>? \\(_, name) -> view (\"Hello, \" <> name) where question :: Task h Text question = view \"What is your name?\" promptName :: Task h Text promptName = enter This will produce the following application when run:","title":"Usage"}]}